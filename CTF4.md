CTF Semana #4 (Linux Environment)

No início deste CTF, foram lidas as intruções e anotadas as informações pertinentes. Tais informações seriam o objetivo do CTF, que se tratava da subverção de um script presente dentro do próprio servidor pensado ser seguro, a imporância da leitura do "admin_note.txt" uma vez conectado no servidor, o comando necessário para conexão com o servidor, e a verificação de que na pasta onde entrariamos no servidor, estaria presente um script que era corrido com frequência pelo servidor.

De seguida, uma vez conectado com o servidor, usámos o comando "cat admin_note.txt" para imprimir os conteúdos do ficheiro na consola. Segundo o que foi lido, concluímos que o usuário, cujas pasta estávamos a explorar, não tinha acesso à pasta "/tmp" presente na root do sistema. Após alguma navegação, verificamos que nós tinhamos acesso total a essa pasta.

Após mais alguma inspeção à pasta onde nos encontravamos, "/home/flag_reader", e executando o comando "ls -l" para mostrar as permições e owners de ficheiros, verificamos que o ficheiro presente "env" era um symbolic link para o ficheiro presente na pasta "/tmp". O seu path absoluto seria "/tmp/env".

Imprimindo os conteúdos do script "my_script.sh", analisamos que este carregava as variáveis presentes no fichero "env" com o path absoluto "/home/flag_reader/env" para as variáveis do usuário que corria o script e de seguida corria o binário "reader" presente localmente. Apõs verificar a permição de execução para todos os usuários deste script, decidimos corre-lo. Após isso, decidimos correr também o binário "reader" por nós mesmos uma vez que este também presentava permições de execução a todos os usuários. Anotámos o que o script e o binário imprimiram e verificamos que de facto o script executava o binário.

Após verificar a existência de mais um ficheiro dentro da pasta, "main.c", decidimos avaliar o que este presentava. Como comando "cat main.c", imprimimos os seus conteúdos para a consola. Analisando este código e comparando-o com a impressão realizada pelo binário "reader", concluímos que o binário "reader" seria o ficheiro resultante da compilação do código presente em "main.c". Uma vez com esta informação, concluímos que para subverter o script, teríamos de dar overwrite à chamada da função "access" presente em "main.c" que era usada para verificar a existência do ficheiro "flag.txt" dentro da pasta "/flags" presente na root do sistema.

Com isto em mente, criamos um ficheiro "mylib.c" dentro da pasta "/tmp" no qual preenchemos com uma única função chamada "access" que recebia dois argumentos, tal como aquela chamada em "main.c". Esta função "access" apenas faria uma system call para a execução de um comando com uma shell alternativa com as permissões do utilizador que teria corrido esta função. Esta system call seria executada com o comando "system(comando)" dentro da função "access" e o comando que decidimos utlizar foi "/usr/bin/cat /flags/flag.txt >> /tmp/myfile.txt", cuja funcionalidade seria copiar os conteúdos presentes no ficheiro "flag.txt" para um ficheiro futuramente criado por nós chamado "myfile.txt". Foi escolhido alojá-lo na pasta "/tmp" pois devido à prévia verificação das permissões que o nosso usuário presentava dentro desta pasta. A colocação do código no ficheiro "mylib.c" foi realizado com o uso do comando "echo" com a flag "-e". A utliziação desse comando foi a seguinte: "echo -e '#include <⠀stdlib.h> \nint access(const char *pathname, int mode) \{\n system("/usr/bin/cat /flags/flag.txt >> /tmp/myfile.txt");\n return 0;\n}' > mylib.c"
Criamos entao o ficheiro "myfile.txt" dentro da pasta "/tmp".

Uma vez criado este código, compilamos este código dentro do servidor para um ficheiro objeto chamado "mylib.o". Com mais um comando, compilamos este ficheiro para uma libraria partilhada chamada "mylib". Os comandos usados para tal resultado foram "gcc -fPIC -g -c mylib.c" seguido de "gcc -shared -o mylib mylib.o -lc". Com agora a presença de uma libraria partilhada na pasta "/tmp", faltava agora manipular o script de forma a carregar esta libraria antes de correr o binário "reader". Lembrando que o ficheiro "/home/flag_reader/env" era um symbolic link para o ficheiro "/tmp/env", para o qual tinhamos permissões completas de edição, decidimos escrever neste ficheiro a variável de ambiente que iria permitir o overwirte de função "access" que o binário chama com a função "access" da nossa autoria. Assim, escrevemos no ficheiro "env" a variável de ambiente "LD_PRELOAD=/tmp/mylib" utilizando o comando "echo LD_PRELOAD=/tmp/mylib > env" uma vez situado com a consola na pasta "/tmp".

Antes de esperar pela execução do script pela parte do servidor, que iria carregar agora a nossa libraria e correr o binário "reader" que chamaria a nossa função "access", foi relembrado que o usuario "flag_reader" não teria qualquer permissão dentro da pasta "/tmp" segundo as notas do administrador. Assumindo que este seria o usuário com o qual o script estaria a ser executado, decidimos alterar as permissões do nosso ficheiro "myfile.txt" para assegurar a possibilidade de escrita da flag no ficheiro por parte do servidor. Com isto, executamos o comando "chmod 777 myfile.txt" que assegurou que todos os usuários teriam permissão para escrever no nosso ficheiro.

Aguardando por volta de um minuto, verificamos o conteúdo do ficheiro "myfile.txt" e como esperado, encontrava-se lá a flag que cobiçavamos. Com isto, demos o CTF por completo.
